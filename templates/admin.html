<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>GSchool Admin</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 1.5rem;
      color: #222;
      background: #f7f7fb;
    }
    h1 {
      margin-bottom: 0.5rem;
    }
    h2, h3, h4 {
      margin-top: 1.6rem;
      margin-bottom: 0.6rem;
    }
    section, article, fieldset {
      background: #fff;
      border-radius: 8px;
      padding: 1rem 1.2rem;
      margin-bottom: 1rem;
      box-shadow: 0 1px 3px rgba(0,0,0,0.07);
    }
    fieldset {
      border: 1px solid #ddd;
    }
    legend {
      font-weight: 600;
      padding: 0 0.25rem;
    }
    label {
      display: block;
      margin-bottom: 0.4rem;
    }
    input[type="text"],
    input[type="number"],
    input[type="time"],
    input[type="url"],
    select,
    textarea {
      width: 100%;
      box-sizing: border-box;
      padding: 0.35rem 0.5rem;
      border-radius: 4px;
      border: 1px solid #ccc;
      font-size: 0.9rem;
      margin-top: 0.15rem;
    }
    textarea {
      resize: vertical;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      font-size: 0.9rem;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 0.35rem 0.5rem;
      vertical-align: middle;
    }
    th {
      background: #f0f0f5;
      text-align: left;
    }
    .mini {
      font-size: 0.82rem;
      color: #555;
    }
    .grid2 {
      display: grid;
      grid-template-columns: repeat(auto-fit,minmax(220px,1fr));
      gap: 0.75rem;
      margin-bottom: 0.5rem;
    }
    .grid3 {
      display: grid;
      grid-template-columns: repeat(auto-fit,minmax(150px,1fr));
      gap: 0.75rem;
      margin-bottom: 0.5rem;
    }
    button {
      border-radius: 4px;
      border: none;
      padding: 0.35rem 0.8rem;
      font-size: 0.9rem;
      cursor: pointer;
      margin-right: 0.4rem;
      margin-top: 0.3rem;
    }
    button.primary {
      background: #2563eb;
      color: #fff;
    }
    button.secondary {
      background: #e5e7eb;
      color: #111827;
    }
    button.danger {
      background: #dc2626;
      color: #fff;
    }
    button.small {
      font-size: 0.8rem;
      padding: 0.25rem 0.6rem;
    }
    ul#policiesList {
      list-style: none;
      padding-left: 0;
    }
    ul#policiesList li {
      padding: 0.2rem 0.3rem;
      border-radius: 4px;
    }
    ul#policiesList li.selected {
      background: #e0f2fe;
    }
    .flex-row {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
    }
    .flex-1 { flex: 1; min-width: 260px; }
    .flex-2 { flex: 2; min-width: 320px; }
    #policyCategoriesContainer label {
      display: inline-block;
      margin-right: 0.75rem;
      margin-bottom: 0.2rem;
    }
    #policyCategoriesContainer {
      max-height: 140px;
      overflow-y: auto;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 0.4rem;
      background: #fafafa;
    }
  </style>
</head>
<body>
  <h1>GSchool Admin</h1>
  <p class="mini">
    Admin controls for AI categories, schedules, and policies. Students use the Chrome extension,
    which calls this server to get their active policy and filtering rules.
  </p>

  <!-- =========================
       AI Categories & Schedule
       ========================= -->
  <section>
    <h2>Categories (AI-powered)</h2>
    <p class="mini">
      These categories come from the AI classifier. You can toggle blocking globally here.
      Per-policy overrides are configured in the Policies section below.
    </p>
    <article>
      <table>
        <thead>
          <tr>
            <th>Category</th>
            <th>Blocked globally?</th>
            <th>Block URL (optional)</th>
            <th>Save</th>
          </tr>
        </thead>
        <tbody id="cats">
          <tr><td colspan="4" class="mini">Loading categories…</td></tr>
        </tbody>
      </table>
      <div id="catMsg" class="mini"></div>
    </article>

    <h3>Schedules per Category</h3>
    <article>
      <p class="mini">
        Here you can define a global schedule for individual AI categories. Policy-specific schedules are handled inside each policy.
      </p>
      <div class="grid2">
        <label>Category
          <select id="schedCategory"></select>
        </label>
        <label>
          <input type="checkbox" id="schedEnabled"> Use schedule for this category
        </label>
      </div>
      <div class="grid3">
        <label>Start (HH:MM)
          <input type="time" id="schedStart">
        </label>
        <label>End (HH:MM)
          <input type="time" id="schedEnd">
        </label>
        <label>
          <input type="checkbox" id="schedWeekdays"> Weekdays only
        </label>
      </div>
      <button id="saveScheduleBtn" class="secondary small">Save Category Schedule</button>
      <span id="schedMsg" class="mini"></span>
    </article>
  </section>

  <!-- =========================
       Policies
       ========================= -->
  <section>
    <h2>Policies</h2>
    <article>
      <p class="mini">
        Policies are presets that combine AI categories (from the classifier) and manual allow/block URL lists.
        For each student, the extension asks this server which policy applies. The rules are:
        <br>
        1) User-specific policy → 2) Class/group policy → 3) Default policy. Among those, the highest <b>Priority</b> (largest number)
        that is currently active by schedule wins.
      </p>

      <div class="flex-row">
        <!-- Policy list -->
        <div class="flex-1">
          <h4>Existing Policies</h4>
          <ul id="policiesList" class="mini"></ul>
          <button id="newPolicyBtn" class="secondary small">New Policy</button>
          <button id="deletePolicyBtn" class="danger small">Delete Selected</button>
        </div>

        <!-- Policy editor -->
        <div class="flex-2">
          <h4>Edit Policy</h4>
          <div class="grid2">
            <label>Policy ID
              <input id="policyId" type="text" readonly placeholder="auto-generated for new">
            </label>
            <label>Policy Name
              <input id="policyName" type="text" placeholder="e.g. Exam Lockdown">
            </label>
          </div>

          <div class="grid2">
            <label>Priority
              <input id="policyPriority" type="number" value="0">
              <small class="mini">Higher number = higher priority (wins when multiple apply).</small>
            </label>
            <label>
              <input id="policyActive" type="checkbox" checked> Active
            </label>
          </div>

          <fieldset>
            <legend>Schedule (optional, for this policy)</legend>
            <label>
              <input id="policyScheduleEnabled" type="checkbox"> Use schedule for this policy
            </label>
            <div class="grid3">
              <label>Start (HH:MM)
                <input id="policyStart" type="time">
              </label>
              <label>End (HH:MM)
                <input id="policyEnd" type="time">
              </label>
              <label>
                <input id="policyWeekdaysOnly" type="checkbox"> Weekdays only
              </label>
            </div>
            <small class="mini">
              If schedule is off, this policy is always active (as long as "Active" is checked).
            </small>
          </fieldset>

          <fieldset>
            <legend>Categories (from AI classify)</legend>
            <p class="mini">
              Tick categories that should be <b>blocked</b> by this policy.
              Unticked categories follow the global category settings above.
            </p>
            <div id="policyCategoriesContainer" class="mini">
              <!-- checkboxes filled from /api/ai/categories -->
            </div>
          </fieldset>

          <fieldset>
            <legend>Manual URLs (for this policy)</legend>
            <label>Block URLs (one per line, supports * wildcards)
              <textarea id="policyBlockUrls" rows="3"></textarea>
            </label>
            <label>Allow URLs (one per line, supports * wildcards)
              <textarea id="policyAllowUrls" rows="3"></textarea>
            </label>
          </fieldset>

          <fieldset>
            <legend>Default policy</legend>
            <label>Default for unassigned users?
              <select id="policyIsDefault">
                <option value="no">No</option>
                <option value="yes">Yes</option>
              </select>
            </label>
            <p class="mini">
              <b>Currently default policy:</b>
              <span id="currentDefaultLabel">(none)</span>
            </p>
            <p class="mini">
              Default applies to students who do <u>not</u> have a user-specific or class/group policy assigned.
            </p>
          </fieldset>

          <button id="savePolicyBtn" class="primary">Save Policy</button>
          <small id="policiesMsg" class="mini"></small>
        </div>
      </div>
    </article>
  </section>

  <script>
    // ============ Categories & Schedules ============
    let _latestCategories = [];

    function updateScheduleForm() {
      const cats = _latestCategories || [];
      const sel = document.getElementById('schedCategory');
      if (!sel) return;

      let selectedName = sel.value;
      if (!selectedName && cats.length) {
        selectedName = cats[0].name;
        sel.value = selectedName;
      }

      const cat = cats.find(c => c.name === selectedName) || {};
      const sched = cat.schedule || null;

      const enabledEl = document.getElementById('schedEnabled');
      const startEl = document.getElementById('schedStart');
      const endEl = document.getElementById('schedEnd');
      const weekdaysEl = document.getElementById('schedWeekdays');
      if (!enabledEl || !startEl || !endEl || !weekdaysEl) return;

      enabledEl.checked = !!(sched && sched.enabled);
      startEl.value = (sched && sched.start) || "";
      endEl.value = (sched && sched.end) || "";
      weekdaysEl.checked = !!(sched && sched.weekdays_only);
    }

    async function refresh() {
      const catMsg = document.getElementById('catMsg');
      const tbody = document.getElementById('cats');
      if (tbody) tbody.innerHTML = '';

      // 1) Categories from AI API
      try {
        const res = await fetch('/api/ai/categories');
        if (!res.ok) throw new Error('AI categories unavailable');
        const j = await res.json();
        const cats = j.categories || [];
        _latestCategories = cats;

        // Populate categories table
        if (tbody) {
          if (!cats.length) {
            tbody.innerHTML = '<tr><td colspan="4">No AI categories yet.</td></tr>';
          } else {
            cats.forEach(c => {
              const tr = document.createElement('tr');
              tr.innerHTML = `
                <td><b>${c.name}</b></td>
                <td><input type="checkbox" ${c.blocked ? 'checked' : ''} data-name="${c.name}" class="blk"></td>
                <td><input type="url" value="${c.block_url || ''}" data-name="${c.name}" class="bp"></td>
                <td><button data-name="${c.name}" class="saveCat small">Save</button></td>
              `;
              tbody.appendChild(tr);
            });
          }
        }

        // Populate schedule category dropdown
        const sel = document.getElementById('schedCategory');
        if (sel) {
          sel.innerHTML = '';
          cats.forEach(c => {
            const opt = document.createElement('option');
            opt.value = c.name;
            opt.textContent = c.name;
            sel.appendChild(opt);
          });
        }
        updateScheduleForm();

        if (catMsg) catMsg.textContent = '';
      } catch (e) {
        console.error('Error loading categories', e);
        if (catMsg) catMsg.textContent = 'Error loading AI categories.';
      }

      // Also re-render policy category checkboxes based on latest categories
      renderPolicyCategoryCheckboxes();
    }

    async function saveCategory(name) {
      const catMsg = document.getElementById('catMsg');
      try {
        const row = document.querySelector(`input.blk[data-name="${name}"]`)?.closest('tr');
        if (!row) return;
        const chk = row.querySelector('input.blk');
        const urlInput = row.querySelector('input.bp');
        const body = {
          name: name,
          blocked: !!(chk && chk.checked),
          block_url: urlInput ? (urlInput.value || "") : ""
        };
        const res = await fetch('/api/ai/category', {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify(body)
        });
        if (!res.ok) throw new Error('Failed to save category');
        if (catMsg) { catMsg.textContent = 'Category saved.'; catMsg.style.color = 'green'; }
        // refresh to sync
        refresh();
      } catch (e) {
        console.error('saveCategory error', e);
        if (catMsg) { catMsg.textContent = 'Error saving category.'; catMsg.style.color = 'crimson'; }
      }
    }

    async function saveCategorySchedule() {
      const msg = document.getElementById('schedMsg');
      if (msg) { msg.textContent = 'Saving…'; msg.style.color = 'inherit'; }
      try {
        const sel = document.getElementById('schedCategory');
        const enabledEl = document.getElementById('schedEnabled');
        const startEl = document.getElementById('schedStart');
        const endEl = document.getElementById('schedEnd');
        const weekdaysEl = document.getElementById('schedWeekdays');
        if (!sel) return;
        const name = sel.value;
        const body = {
          name,
          schedule: {
            enabled: !!(enabledEl && enabledEl.checked),
            start: startEl ? (startEl.value || "") : "",
            end: endEl ? (endEl.value || "") : "",
            weekdays_only: weekdaysEl ? !!weekdaysEl.checked : false
          }
        };
        const res = await fetch('/api/ai/category_schedule', {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify(body)
        });
        if (!res.ok) throw new Error('Failed');
        if (msg) { msg.textContent = 'Schedule saved.'; msg.style.color = 'green'; }
        refresh();
      } catch (e) {
        console.error('saveCategorySchedule error', e);
        if (msg) { msg.textContent = 'Error saving schedule.'; msg.style.color = 'crimson'; }
      }
    }

    // ============ Policies (UI editor) ============
    let POLICIES = {};
    let DEFAULT_POLICY_ID = null;
    let CURRENT_POLICY_ID = null;

    function renderPolicyCategoryCheckboxes(policy) {
      const container = document.getElementById('policyCategoriesContainer');
      if (!container) return;
      const cats = _latestCategories || [];
      const blockedSet = new Set((policy && policy.blocked_categories) || []);
      container.innerHTML = '';
      if (!cats.length) {
        container.textContent = 'No AI categories yet. They will appear here once the classifier has categories.';
        return;
      }
      cats.forEach(c => {
        const label = document.createElement('label');
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.dataset.catName = c.name;
        if (blockedSet.has(c.name)) cb.checked = true;
        label.appendChild(cb);
        label.appendChild(document.createTextNode(' ' + c.name));
        container.appendChild(label);
        container.appendChild(document.createElement('br'));
      });
    }

    function normalizeListFromInput(val) {
      if (!val) return [];
      return val
        .split(/[\n,]/)
        .map(s => s.trim())
        .filter(Boolean);
    }

    function fillPolicyForm(p) {
      const idEl = document.getElementById('policyId');
      const nameEl = document.getElementById('policyName');
      const prioEl = document.getElementById('policyPriority');
      const activeEl = document.getElementById('policyActive');
      const schEnEl = document.getElementById('policyScheduleEnabled');
      const startEl = document.getElementById('policyStart');
      const endEl = document.getElementById('policyEnd');
      const wdEl = document.getElementById('policyWeekdaysOnly');
      const buEl = document.getElementById('policyBlockUrls');
      const auEl = document.getElementById('policyAllowUrls');
      const isDefEl = document.getElementById('policyIsDefault');

      if (!p) {
        CURRENT_POLICY_ID = null;
        if (idEl) idEl.value = "";
        if (nameEl) nameEl.value = "";
        if (prioEl) prioEl.value = "0";
        if (activeEl) activeEl.checked = true;
        if (schEnEl) schEnEl.checked = false;
        if (startEl) startEl.value = "";
        if (endEl) endEl.value = "";
        if (wdEl) wdEl.checked = false;
        if (buEl) buEl.value = "";
        if (auEl) auEl.value = "";
        if (isDefEl) isDefEl.value = "no";
        renderPolicyCategoryCheckboxes(null);
        return;
      }

      CURRENT_POLICY_ID = p.id || "";
      if (idEl) idEl.value = p.id || "";
      if (nameEl) nameEl.value = p.name || "";
      if (prioEl) prioEl.value = typeof p.priority === "number" ? p.priority : 0;
      if (activeEl) activeEl.checked = p.active !== false;

      const sch = p.schedule || {};
      if (schEnEl) schEnEl.checked = !!sch.enabled;
      if (startEl) startEl.value = sch.start || "";
      if (endEl) endEl.value = sch.end || "";
      if (wdEl) wdEl.checked = !!sch.weekdays_only;

      if (buEl) buEl.value = (p.block_urls || []).join("\n");
      if (auEl) auEl.value = (p.allow_urls || []).join("\n");

      if (isDefEl) {
        isDefEl.value = (p.id && p.id === DEFAULT_POLICY_ID) ? "yes" : "no";
      }

      renderPolicyCategoryCheckboxes(p);
    }

    function renderPoliciesList() {
      const ul = document.getElementById('policiesList');
      const defLabel = document.getElementById('currentDefaultLabel');
      if (!ul) return;
      ul.innerHTML = "";
      const ids = Object.keys(POLICIES).sort((a, b) => {
        const pa = POLICIES[a] || {};
        const pb = POLICIES[b] || {};
        const da = (pa.priority || 0);
        const db = (pb.priority || 0);
        if (da !== db) return db - da;
        const na = (pa.name || "").toLowerCase();
        const nb = (pb.name || "").toLowerCase();
        return na.localeCompare(nb);
      });

      ids.forEach(id => {
        const p = POLICIES[id];
        const li = document.createElement('li');
        let label = `${p.name || '(unnamed)'} [prio ${p.priority || 0}]`;
        if (id === DEFAULT_POLICY_ID) label += ' (default)';
        li.textContent = label;
        li.dataset.id = id;
        li.style.cursor = 'pointer';
        li.addEventListener('click', () => {
          CURRENT_POLICY_ID = id;
          fillPolicyForm(POLICIES[id]);
          const siblings = ul.querySelectorAll('li');
          siblings.forEach(x => x.classList.remove('selected'));
          li.classList.add('selected');
        });
        ul.appendChild(li);
      });

      if (defLabel) {
        if (DEFAULT_POLICY_ID && POLICIES[DEFAULT_POLICY_ID]) {
          defLabel.textContent = `${POLICIES[DEFAULT_POLICY_ID].name || DEFAULT_POLICY_ID}`;
        } else {
          defLabel.textContent = '(none)';
        }
      }
    }

    async function loadPoliciesUI() {
      try {
        const r = await fetch('/api/policies');
        if (!r.ok) return;
        const j = await r.json();
        if (!j.ok) return;
        POLICIES = j.policies || {};
        DEFAULT_POLICY_ID = j.default_policy_id || null;
        renderPoliciesList();
        const firstId = Object.keys(POLICIES)[0];
        if (firstId) {
          fillPolicyForm(POLICIES[firstId]);
          CURRENT_POLICY_ID = firstId;
        } else {
          fillPolicyForm(null);
        }
      } catch (e) {
        console.error('loadPoliciesUI', e);
      }
    }

    async function saveCurrentPolicy() {
      const msg = document.getElementById('policiesMsg');
      if (msg) { msg.textContent = 'Saving…'; msg.style.color = 'inherit'; }

      try {
        const idEl = document.getElementById('policyId');
        const nameEl = document.getElementById('policyName');
        const prioEl = document.getElementById('policyPriority');
        const activeEl = document.getElementById('policyActive');
        const schEnEl = document.getElementById('policyScheduleEnabled');
        const startEl = document.getElementById('policyStart');
        const endEl = document.getElementById('policyEnd');
        const wdEl = document.getElementById('policyWeekdaysOnly');
        const buEl = document.getElementById('policyBlockUrls');
        const auEl = document.getElementById('policyAllowUrls');
        const isDefEl = document.getElementById('policyIsDefault');

        // collect blocked categories from checkboxes
        const bc = [];
        const catContainer = document.getElementById('policyCategoriesContainer');
        if (catContainer) {
          catContainer.querySelectorAll('input[type="checkbox"][data-cat-name]').forEach(cb => {
            if (cb.checked) bc.push(cb.dataset.catName);
          });
        }

        const body = {
          id: (idEl && idEl.value.trim()) || "",
          name: (nameEl && nameEl.value.trim()) || "Untitled Policy",
          priority: prioEl ? parseInt(prioEl.value || "0", 10) : 0,
          active: activeEl ? !!activeEl.checked : true,
          blocked_categories: bc,
          allowed_categories: [], // not used in this UI, but backend supports it
          block_urls: normalizeListFromInput(buEl && buEl.value.replace(/,/g, '\n')),
          allow_urls: normalizeListFromInput(auEl && auEl.value.replace(/,/g, '\n')),
          schedule: {
            enabled: schEnEl ? !!schEnEl.checked : false,
            start: startEl ? (startEl.value || "") : "",
            end: endEl ? (endEl.value || "") : "",
            weekdays_only: wdEl ? !!wdEl.checked : false
          }
        };

        const wantDefault = isDefEl && isDefEl.value === "yes";

        // First save policy
        const r = await fetch('/api/policies', {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify(body)
        });
        const j = await r.json();
        if (!j.ok) {
          if (msg) { msg.textContent = 'Error saving policy'; msg.style.color = 'crimson'; }
          return;
        }
        const saved = j.policy;
        POLICIES[saved.id] = saved;
        CURRENT_POLICY_ID = saved.id;

        // Now handle default flag via /api/policy_assignments
        if (wantDefault) {
          await fetch('/api/policy_assignments', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ default_policy_id: saved.id })
          });
          DEFAULT_POLICY_ID = saved.id;
        } else if (!wantDefault && DEFAULT_POLICY_ID === saved.id) {
          await fetch('/api/policy_assignments', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ default_policy_id: null })
          });
          DEFAULT_POLICY_ID = null;
        }

        fillPolicyForm(saved);
        renderPoliciesList();
        if (msg) { msg.textContent = 'Policy saved'; msg.style.color = 'green'; }
      } catch (e) {
        console.error('saveCurrentPolicy', e);
        const msg = document.getElementById('policiesMsg');
        if (msg) { msg.textContent = 'Error saving policy'; msg.style.color = 'crimson'; }
      }
    }

    async function deleteCurrentPolicy() {
      const msg = document.getElementById('policiesMsg');
      if (!CURRENT_POLICY_ID) {
        if (msg) { msg.textContent = 'No policy selected'; msg.style.color = 'crimson'; }
        return;
      }
      if (!confirm('Delete this policy?')) return;
      try {
        await fetch('/api/policies', {
          method: 'DELETE',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({ id: CURRENT_POLICY_ID })
        });
        delete POLICIES[CURRENT_POLICY_ID];
        if (CURRENT_POLICY_ID === DEFAULT_POLICY_ID) DEFAULT_POLICY_ID = null;
        CURRENT_POLICY_ID = null;
        fillPolicyForm(null);
        renderPoliciesList();
        if (msg) { msg.textContent = 'Policy deleted'; msg.style.color = 'green'; }
      } catch (e) {
        console.error('deleteCurrentPolicy', e);
        if (msg) { msg.textContent = 'Error deleting policy'; msg.style.color = 'crimson'; }
      }
    }

    document.addEventListener('DOMContentLoaded', function() {
      // Categories / schedules
      refresh();
      const schedSel = document.getElementById('schedCategory');
      if (schedSel) schedSel.addEventListener('change', updateScheduleForm);
      const saveSchedBtn = document.getElementById('saveScheduleBtn');
      if (saveSchedBtn) saveSchedBtn.addEventListener('click', function(ev) {
        ev.preventDefault();
        saveCategorySchedule();
      });
      // Delegate save button for categories
      const catsTbody = document.getElementById('cats');
      if (catsTbody) {
        catsTbody.addEventListener('click', function(ev) {
          const btn = ev.target.closest('.saveCat');
          if (!btn) return;
          ev.preventDefault();
          const name = btn.getAttribute('data-name');
          if (name) saveCategory(name);
        });
      }

      // Policies UI
      loadPoliciesUI();
      const saveBtn = document.getElementById('savePolicyBtn');
      const newBtn = document.getElementById('newPolicyBtn');
      const delBtn = document.getElementById('deletePolicyBtn');
      if (saveBtn) saveBtn.addEventListener('click', function(ev) {
        ev.preventDefault();
        saveCurrentPolicy();
      });
      if (newBtn) newBtn.addEventListener('click', function(ev) {
        ev.preventDefault();
        CURRENT_POLICY_ID = null;
        fillPolicyForm(null);
      });
      if (delBtn) delBtn.addEventListener('click', function(ev) {
        ev.preventDefault();
        deleteCurrentPolicy();
      });
    });
  </script>
</body>
</html>
